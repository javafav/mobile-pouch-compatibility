package com.mobilematching.admin.util;
import com.opencsv.*;
import com.opencsv.exceptions.CsvException;

import java.io.*;
import java.util.*;

public class SmartCsvFixerWithOpenCsv {

    private static final List<String> headers = Arrays.asList(
        "institute_id", "dob", "nok", "city", "cnic", "email", "gender", "postal_code", "campus_id", "name",
        "district", "province", "phone", "address", "country", "religion", "nationality", "occupation",
        "blood_group", "permanent_address", "phone_office", "phone_home", "marital_status", "g_name",
        "g_relation", "g_phone", "g_email", "g_address", "degree_program_id", "guardian_occupation",
        "guardian_office_address", "guardian_income", "g_cnic", "special_person", "hostel_required", "sports",
        "transport_required", "quran_course", "hifz_course", "hifz_institute", "hifz_completion_year",
        "migration", "provisional", "shift", "session", "entry_test_marks", "admission_fee", "challan_number",
        "challan_date", "extra_activity", "fee_discount", "punishment", "punishment_reason", "punishment_detail",
        "fee_type", "degree_awarding_institute", "medium", "batch", "admission_type", "previous_rollno",
        "previous_regno", "previous_institute", "date_of_completion", "previous_board", "pre_result_date",
        "last_institute_id", "last_board_id", "admission_date", "last_degree", "last_session", "last_session_year",
        "picture", "quranic_education", "alumni", "migration_reason", "last_campus_id", "program_campus_id",
        "entry_test_campus", "religious_minority", "nok_email", "nok_phone", "g_nationality", "user_id"
    );

    public static void main(String[] args) {
        String inputFile = "input.csv";
        String outputFile = "output.csv";

        try (CSVReader reader = new CSVReaderBuilder(new FileReader(inputFile)).withSkipLines(0).build();
             CSVWriter writer = new CSVWriter(new FileWriter(outputFile))) {

            // Write the correct header
            writer.writeNext(headers.toArray(new String[0]));

            List<String[]> allRows = reader.readAll();

            for (String[] row : allRows) {
                Map<String, String> record = detectAndFixRecord(row);

                String[] ordered = new String[headers.size()];
                for (int i = 0; i < headers.size(); i++) {
                    ordered[i] = record.getOrDefault(headers.get(i), "");
                }
                writer.writeNext(ordered);
            }

            System.out.println("Fixed and written successfully to " + outputFile);

        } catch (IOException | CsvException e) {
            e.printStackTrace();
        }
    }

    private static Map<String, String> detectAndFixRecord(String[] fields) {
        Map<String, String> record = new HashMap<>();

        for (String field : fields) {
            String trimmed = field == null ? "" : field.trim();

            if (trimmed.isEmpty()) continue;

            if (isEmail(trimmed)) {
                assignIfEmpty(record, "email", trimmed);
            } else if (isCnic(trimmed)) {
                assignIfEmpty(record, "cnic", trimmed);
            } else if (isPhone(trimmed)) {
                assignIfEmpty(record, "phone", trimmed);
            } else if (isDob(trimmed)) {
                assignIfEmpty(record, "dob", trimmed);
            } else if (isNumber(trimmed)) {
                assignIfEmpty(record, "institute_id", trimmed); // fallback
            } else {
                assignFirstAvailableTextField(record, trimmed);
            }
        }

        return record;
    }

    private static void assignIfEmpty(Map<String, String> record, String key, String value) {
        if (!record.containsKey(key) || record.get(key).isEmpty()) {
            record.put(key, value);
        }
    }

    private static void assignFirstAvailableTextField(Map<String, String> record, String value) {
        List<String> textFieldsPriority = Arrays.asList(
            "name", "address", "city", "district", "province", "country", "religion", "nationality", "occupation",
            "guardian_occupation", "g_name", "g_relation", "g_address", "previous_institute"
        );

        for (String field : textFieldsPriority) {
            if (!record.containsKey(field) || record.get(field).isEmpty()) {
                record.put(field, value);
                return;
            }
        }
        assignIfEmpty(record, "extra_activity", value);
    }

    // PATTERN DETECTORS
    private static boolean isEmail(String value) {
        return value.contains("@") && value.contains(".");
    }

    private static boolean isCnic(String value) {
        return value.matches("\\d{5}-\\d{7}-\\d");
    }

    private static boolean isPhone(String value) {
        return value.matches("(\\+92|0)3\\d{9}");
    }

    private static boolean isDob(String value) {
        return value.matches("\\d{2}/\\d{2}/\\d{4}") || value.matches("\\d{4}-\\d{2}-\\d{2}");
    }

    private static boolean isNumber(String value) {
        return value.matches("\\d+");
    }
}

